export density_matrix_dephased_identical, white_noise_identical
export krauss_operator_single_species, krauss_operators_dual_species
export photon_loss_channel, density_matrix_dephased_krauss_identical

"""
    density_matrix_dephased_identical(Ψ, ϵ)

Generate a dephased density matrix for a four photon system with two pairs of identical
photons. The dephasing is modeled by a convex combination of the pure state density matrix
derived from the wave function `Ψ` with weight `1 - ϵ` and a white noise density matrix with
weight `ϵ`. The white noise density matrix is generated by the function
`white_noise_identical`.

See also [`white_noise_identical`](@ref), [`density_matrix`](@ref),
['density_matrix_dephased_krauss_identical`](@ref).

"""
function density_matrix_dephased_identical(Ψ, ϵ)
    Ψ = convert(Vector{ComplexF64}, Ψ)::Vector{ComplexF64}
    ϵ = convert(Float64, ϵ)::Float64
    d_hilbert_space = Int(sqrt(length(Ψ)))

    N = Int(-1 / 4 + sqrt(1 / 16 + d_hilbert_space / 2)) # p-q formula

    @argcheck ϵ ≥ 0
    @argcheck ϵ ≤ 1

    ρ_pure = density_matrix(Ψ)
    ρ = (1 - ϵ) * ρ_pure + ϵ * white_noise_identical(N)
    return ρ
end


"""
    white_noise_identical(N)

Generate a white noise density matrix for a four photon system with two pairs of identical
photons. This noise term has equal populations for all possible combinations of one signal-
idler pair in the same time bin and two uncorrelated signal idler photons, caused by, e.g.,
photon loss and subsequent dark count or only one SPDC pair created and two dark counts.

See also [`density_matrix_dephased_identical`](@ref), [`photon_loss_channel`](@ref),
[density_matrix_dephased_krauss_identical`](@ref).

"""
function white_noise_identical(N)
    d_local_hs_bl = N * (2 * N + 1)
    # local Hilbert space dimension of two identical photons in the bin-loop basis
    ρ_diag = zeros(ComplexF64, d_local_hs_bl^2)
    for l in 0:N - 1, m in l:N - 1
        for k in 0:N - 1
            # dark count in kth time bin
            if k < m
                j = lcmk2j_super_identical(N, l, 0, m, 0, k, 0, m, 0)
                ρ_diag[j] = 1 # flagging potential detection even by dark count
                j = lcmk2j_super_identical(N, k, 0, m, 0, l, 0, m, 0)
                ρ_diag[j] = 1
                if k ≤ l
                    # make sure k, l are in ascending order
                    j = lcmk2j_super_identical(N, l, 0, m, 0, k, 0, l, 0)
                    ρ_diag[j] = 1
                    j = lcmk2j_super_identical(N, k, 0, l, 0, l, 0, m, 0)
                    ρ_diag[j] = 1
                else
                    j = lcmk2j_super_identical(N, l, 0, m, 0, l, 0, k, 0)
                    ρ_diag[j] = 1
                    j = lcmk2j_super_identical(N, l, 0, k, 0, l, 0, m, 0)
                    ρ_diag[j] = 1
                end
            else
                j = lcmk2j_super_identical(N, l, 0, m, 0, m, 0, k, 0)
                ρ_diag[j] = 1
                j = lcmk2j_super_identical(N, m, 0, k, 0, l, 0, m, 0)
                ρ_diag[j] = 1
            end
        end
    end

   ρ_diag /= sum(ρ_diag) # normalize
   ρ_noise = Diagonal(ρ_diag) # diagonal density matrix

   return ρ_noise
end

"""
    krauss_operator_single_species(N, l, m)

Generate a Krauss operator for a loss channel of a single species of two indistinguishable
photons. The channel operators are given by the projectors ~ `|l⟩⟨m|`, i.e., transfering a
single photon from time bin `m` to time bin `l`, while keeping the other photon in its
current time bin. In contrast to the function `white_noise_identical`, this noise model
retains some coherence between the different two-photon states.

See also [`krauss_operators_dual_species`](@ref), [`photon_loss_channel`](@ref),
[`density_matrix_dephased_krauss_identical`](@ref), `[white_noise_identical`](@ref).

"""
function krauss_operator_single_species(N, l, m)
    N = convert(Int64, N)::Int64
    l = convert(Int64, l)::Int64
    m = convert(Int64, m)::Int64

    @argcheck N > 0
    @argcheck 0 ≤ l < N
    @argcheck 0 ≤ m < N

    d_local_hs_bl = N * (2 * N + 1)
    # local Hilbert space dimension of two identical photons in the bin-loop basis
    krauss_op = spzeros(Float64, d_local_hs_bl, d_local_hs_bl)
    for n in 0:N - 1
        bin1_init, bin2_init = sort([n, m])
        j1 = lcmk2j_identical(N, bin1_init, 0, bin2_init, 0)
        bin1_after, bin2_after = sort([n, l])
        j2 = lcmk2j_identical(N, bin1_after, 0, bin2_after, 0)
        if l ≠ n ≠ m
            coeff = 1 # tree distinct time bins
        elseif n == l == m
            coeff = 2 # two photons in the same time bin before and after the channel
        else
            coeff = √2 # two photons in the same bin before OR after the channel
        end
        krauss_op[j2, j1] = coeff
    end
    krauss_op *= 1 / (2 * √(N + 1)) # normalization
    return krauss_op
end


"""
    krauss_operators_dual_species(N, l, m)

Two-party version of the function `krauss_operator_single_species`. Return two tensor-
product operators `K_lm ⊗ 1` and `1 ⊗ K_lm`, where K_lm is the single-species Krauss
operator acting on the signal or idler photons, respectively.

See also [`krauss_operator_single_species`](@ref), [`photon_loss_channel`](@ref),
[`density_matrix_dephased_krauss_identical`](@ref), [`white_noise_identical`](@ref),
[`density_matrix_dephased_identical`](@ref).

"""
function krauss_operators_dual_species(N, l, m)
    d_local_hs_bl = N * (2 * N + 1)
    # local Hilbert space dimension of two identical photons in the bin-loop basis
    I_local = Diagonal(ones(d_local_hs_bl))
    krauss_op = krauss_operator_single_species(N, l, m)
    klm_signal = kron(krauss_op, I_local)
    klm_idler = kron(I_local, krauss_op)

    return klm_signal, klm_idler
end

"""
    photon_loss_channel(N, ρ)

Compute the density matrix of the output state after a loss channel acting on a four-photon
state ρ of `N` time bins with two pairs of identical photons. The loss channel is modeled
to act on each pair of photons independently, transferring one photon to a different time
bin while retaining some coherence through the other photon.

See also [`krauss_operator_single_species`](@ref), [`krauss_operators_dual_species`](@ref),
[`density_matrix_dephased_krauss_identical`](@ref), [`white_noise_identical`](@ref),
[`density_matrix_dephased_identical`](@ref).
"""
function photon_loss_channel(N, ρ)
    d_local_hs_bl = N * (2 * N + 1)
    d_full_hs_bl  = d_local_hs_bl ^ 2
    noisy_state = spzeros(ComplexF64, d_full_hs_bl, d_full_hs_bl)
    for l in 0:N - 1, m in 0:N - 1
        klm_signal, klm_idler = krauss_operators_dual_species(N, l, m)
        noisy_state += klm_signal * ρ * klm_signal' + klm_idler * ρ * klm_idler'
    end
    return noisy_state

end

"""
    density_matrix_dephased_krauss_identical(N, ρ, ϵ)

Generate a dephased density matrix for a four photon system with two pairs of identical
photons. The dephasing is modeled by a convex combination of the pure-state density matrix
`ρ` with weight `1 - ϵ` and a noisy density matrix generated by the function
`photon_loss_channel` with weight `ϵ`.

See also [`density_matrix_dephased_identical`](@ref), [`photon_loss_channel`](@ref),
[`white_noise_identical`](@ref).

"""
function density_matrix_dephased_krauss_identical(N, ρ, ϵ)
    ρ_noisy = photon_loss_channel(N, ρ)
    ρ_dephased = (1 - ϵ) * ρ + ϵ * ρ_noisy
    return ρ_dephased
end
